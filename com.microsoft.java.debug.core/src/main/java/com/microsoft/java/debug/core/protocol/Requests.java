/*******************************************************************************
* Copyright (c) 2017-2022 Microsoft Corporation and others.
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*
* Contributors:
*     Microsoft Corporation - initial API and implementation
*******************************************************************************/

package com.microsoft.java.debug.core.protocol;

import java.util.Arrays;
import java.util.Map;
import java.util.Objects;

import com.google.gson.annotations.SerializedName;
import com.microsoft.java.debug.core.protocol.Types.DataBreakpoint;
import com.microsoft.java.debug.core.protocol.Types.Source;

/**
 * The request arguments types defined by VSCode Debug Protocol.
 */
public class Requests {

    public static class ValueFormat {
        public boolean hex;
    }

    public static class Arguments {

    }

    public static class InitializeArguments extends Arguments {
        public String clientID;
        public String adapterID;
        public String pathFormat;
        public boolean linesStartAt1;
        public boolean columnsStartAt1;
        public boolean supportsVariableType;
        public boolean supportsVariablePaging;
        public boolean supportsRunInTerminalRequest;
    }

    public static class ClassFilters {
        /**
         * Restricts the events generated by the request to those whose location is
         * in a class whose name matches this restricted regular expression. Regular
         * expressions are limited to exact matches and patterns that begin with '*'
         * or end with '*'; for example, "*.Foo" or "java.*".
         *
         * This property corresponds to the ClassFilter (include filter). Multiple
         * filters are applied with CUT-OFF AND. Only events that satisfied all
         * filters are placed in the event queue, that means several include filters
         * are handled as "A and B and C", not "A or B or C".
         */
        public String[] allowClasses = new String[0];

        /**
         * Restricts the events generated by the request to those whose location is
         * in a class whose name does not match this restricted regular expression, e.g.
         * "java.*" or "*.Foo".
         *
         * This property corrsponds to the ClassExclusionFilter (exclude filter).
         */
        public String[] skipClasses = new String[0];
    }

    public static class ExceptionFilters extends ClassFilters {
        /**
         * Specifies that exceptions which are instances of refType will be reported.
         * Note: this will include instances of sub-types. If null, all instances
         * will be reported.
         */
        public String[] exceptionTypes = new String[0];
    }

    public static class StepFilters extends ClassFilters {
        /**
         * Deprecated - please use {@link ClassFilters#skipClasses } instead.
         */
        @Deprecated
        public String[] classNameFilters;
        public boolean skipSynthetics;
        public boolean skipStaticInitializers;
        public boolean skipConstructors;
    }

    public static class LaunchBaseArguments extends Arguments {
        public String type;
        public String name;
        public String request;
        public String projectName;
        public String[] sourcePaths = new String[0];
        public StepFilters stepFilters;
    }

    public static enum CONSOLE {
        internalConsole,
        integratedTerminal,
        externalTerminal;
    }

    public static enum ShortenApproach {
        @SerializedName("none")
        NONE,
        @SerializedName("jarmanifest")
        JARMANIFEST,
        @SerializedName("argfile")
        ARGFILE;
    }

    public static class LaunchArguments extends LaunchBaseArguments {
        public String mainClass;
        public String args = "";
        public String vmArgs = "";
        public String encoding = "";
        public String[] classPaths = new String[0];
        public String[] modulePaths = new String[0];
        public String cwd;
        public Map<String, String> env;
        public boolean stopOnEntry;
        public boolean noDebug = false;
        public CONSOLE console = CONSOLE.integratedTerminal;
        public ShortenApproach shortenCommandLine = ShortenApproach.NONE;
        public String launcherScript;
        public String javaExec;
    }

    public static class AttachArguments extends LaunchBaseArguments {
        public String hostName;
        public int port;
        public int timeout = 30000; // Default to 30s.
    }

    public static class RunInTerminalRequestArguments extends Arguments {
        public String kind; // Supported kind should be "integrated" or "external".
        public String title;
        public String cwd; // required.
        public String[] args; // required.
        public Map<String, String> env;

        private RunInTerminalRequestArguments() {
            // do nothing.
        }

        /**
         * Create a RunInTerminalRequestArguments instance.
         * @param cmds
         *            List of command arguments. The first arguments is the command to run.
         * @param cwd
         *            Working directory of the command.
         * @return the request arguments instance.
         */
        public static RunInTerminalRequestArguments createIntegratedTerminal(String[] cmds, String cwd) {
            RunInTerminalRequestArguments requestArgs = new RunInTerminalRequestArguments();
            requestArgs.args = cmds;
            requestArgs.cwd = cwd;
            requestArgs.kind = "integrated";
            return requestArgs;
        }

        /**
         * Create a RunInTerminalRequestArguments instance.
         * @param cmds
         *            List of command arguments. The first arguments is the command to run.
         * @param cwd
         *            Working directory of the command.
         * @param env
         *            Environment key-value pairs that are added to the default environment.
         * @param title
         *            Optional title of the terminal.
         * @return the request arguments instance.
         */
        public static RunInTerminalRequestArguments createIntegratedTerminal(String[] cmds, String cwd, Map<String, String> env, String title) {
            RunInTerminalRequestArguments requestArgs = createIntegratedTerminal(cmds, cwd);
            requestArgs.env = env;
            requestArgs.title = title;
            return requestArgs;
        }

        /**
         * Create a RunInTerminalRequestArguments instance.
         * @param cmds
         *            List of command arguments. The first arguments is the command to run.
         * @param cwd
         *            Working directory of the command.
         * @return the request arguments instance.
         */
        public static RunInTerminalRequestArguments createExternalTerminal(String[] cmds, String cwd) {
            RunInTerminalRequestArguments requestArgs = new RunInTerminalRequestArguments();
            requestArgs.args = cmds;
            requestArgs.cwd = cwd;
            requestArgs.kind = "external";
            return requestArgs;
        }

        /**
         * Create a RunInTerminalRequestArguments instance.
         * @param cmds
         *            List of command arguments. The first arguments is the command to run.
         * @param cwd
         *            Working directory of the command.
         * @param env
         *            Environment key-value pairs that are added to the default environment.
         * @param title
         *            Optional title of the terminal.
         * @return the request arguments instance.
         */
        public static RunInTerminalRequestArguments createExternalTerminal(String[] cmds, String cwd, Map<String, String> env, String title) {
            RunInTerminalRequestArguments requestArgs = createExternalTerminal(cmds, cwd);
            requestArgs.env = env;
            requestArgs.title = title;
            return requestArgs;
        }
    }

    public static class RestartArguments extends Arguments {

    }

    public static class DisconnectArguments extends Arguments {
        // If client doesn't set terminateDebuggee attribute at the DisconnectRequest,
        // the debugger would choose to terminate debuggee by default.
        public boolean terminateDebuggee = true;
        public boolean restart;
    }

    public static class ConfigurationDoneArguments extends Arguments {

    }

    public static class SetBreakpointArguments extends Arguments {
        public Types.Source source;
        public int[] lines = new int[0];
        public Types.SourceBreakpoint[] breakpoints = new Types.SourceBreakpoint[0];
        public boolean sourceModified = false;
    }

    public static class StackTraceArguments extends Arguments {
        public long threadId;
        public int startFrame;
        public int levels;
    }

    public static class SetFunctionBreakpointsArguments extends Arguments {
        public Types.FunctionBreakpoint[] breakpoints;
    }

    public static class SetExceptionBreakpointsArguments extends Arguments {
        public String[] filters = new String[0];
    }

    public static class ExceptionInfoArguments extends Arguments {
        public long threadId;
    }

    public static class ThreadsArguments extends Arguments {

    }

    public static class ContinueArguments extends Arguments {
        public long threadId;
    }

    public static class StepArguments extends Arguments {
        public long threadId;
    }

    public static class NextArguments extends StepArguments {

    }

    public static class StepInArguments extends StepArguments {
        public int targetId;
    }

    public static class StepOutArguments extends StepArguments {

    }

    public static class StepInTargetsArguments extends Arguments {
        public int frameId;
    }

    public static class PauseArguments extends Arguments {
        public long threadId;
    }

    public static class ThreadOperationArguments extends Arguments {
        public long threadId;
    }

    public static class ScopesArguments extends Arguments {
        public int frameId;
    }

    public static class VariablesArguments extends Arguments {
        public int variablesReference = -1;
        public String filter;
        public int start;
        public int count;
        public ValueFormat format;
    }

    public static class SetVariableArguments extends Arguments {
        public int variablesReference;
        public String name;
        public String value;
        public ValueFormat format;
    }

    public static class RefreshVariablesArguments extends Arguments {
        public boolean showStaticVariables = false;
        public boolean showQualifiedNames = false;
        public boolean showHex = false;
        public boolean showLogicalStructure = true;
        public boolean showToString = true;
    }

    public static class SourceArguments extends Arguments {
        public int sourceReference;
    }

    public static class EvaluateArguments extends Arguments {
        public String expression;
        public int frameId;
        public String context;
        public ValueFormat format;
    }

    public static class RedefineClassesArguments extends Arguments {

    }

    public static class RestartFrameArguments extends Arguments {
        public int frameId;
    }

    public static class CompletionsArguments extends Arguments {
        public int frameId;
        public String text;
        public int line;
        public int column;
    }

    public static class DataBreakpointInfoArguments extends Arguments {
        /**
         * Reference to the Variable container if the data breakpoint is requested for a child of the container.
         */
        public int variablesReference;
        /**
         * The name of the Variable's child to obtain data breakpoint information for. If variableReference isn’t provided, this can be an expression.
         */
        public String name;
    }

    public static class SetDataBreakpointsArguments extends Arguments {
        /**
         * The contents of this array replaces all existing data breakpoints. An empty array clears all data breakpoints.
         */
        public DataBreakpoint[] breakpoints;
    }

    public static class InlineValuesArguments extends Arguments {
        public int frameId;
        public InlineVariable[] variables;
    }

    public static class InlineVariable {
        public String expression;
        public String declaringClass;

        @Override
        public int hashCode() {
            return Objects.hash(declaringClass, expression);
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (!(obj instanceof InlineVariable)) {
                return false;
            }
            InlineVariable other = (InlineVariable) obj;
            return Objects.equals(declaringClass, other.declaringClass) && Objects.equals(expression, other.expression);
        }
    }

    /**
     * Arguments for breakpointLocations request.
     */
    public static class BreakpointLocationsArguments extends Arguments {
        /**
         * The source location of the breakpoints; either `source.path` or
         * `source.reference` must be specified.
         */
        public Source source;

        /**
         * Start line of range to search possible breakpoint locations in. If only the
         * line is specified, the request returns all possible locations in that line.
         */
        public int line;

        /**
         * Start column of range to search possible breakpoint locations in. If no
         * start column is given, the first column in the start line is assumed.
         */
        public int column;

        /**
         * End line of range to search possible breakpoint locations in. If no end
         * line is given, then the end line is assumed to be the start line.
         */
        public int endLine;

        /**
         * End column of range to search possible breakpoint locations in. If no end
         * column is given, then it is assumed to be in the last column of the end
         * line.
         */
        public int endColumn;
    }

    public static class RefreshFramesArguments extends Arguments {
        /**
         * If provided, refresh the stack frames of the paused threads that previously
         * requested decompiled sources for classes in the affected root paths.
         * Otherwise, refresh all paused threads.
         */
        public String[] affectedRootPaths;
    }

    public static enum Command {
        INITIALIZE("initialize", InitializeArguments.class),
        LAUNCH("launch", LaunchArguments.class),
        ATTACH("attach", AttachArguments.class),
        DISCONNECT("disconnect", DisconnectArguments.class),
        CONFIGURATIONDONE("configurationDone", ConfigurationDoneArguments.class),
        NEXT("next", NextArguments.class),
        CONTINUE("continue", ContinueArguments.class),
        STEPIN("stepIn", StepInArguments.class),
        STEPOUT("stepOut", StepOutArguments.class),
        STEPIN_TARGETS("stepInTargets",
                StepInTargetsArguments.class),
        PAUSE("pause", PauseArguments.class),
        STACKTRACE("stackTrace", StackTraceArguments.class),
        RESTARTFRAME("restartFrame", RestartFrameArguments.class),
        SCOPES("scopes", ScopesArguments.class),
        VARIABLES("variables", VariablesArguments.class),
        SETVARIABLE("setVariable", SetVariableArguments.class),
        SOURCE("source", SourceArguments.class),
        THREADS("threads", ThreadsArguments.class),
        SETBREAKPOINTS("setBreakpoints", SetBreakpointArguments.class),
        SETEXCEPTIONBREAKPOINTS("setExceptionBreakpoints", SetExceptionBreakpointsArguments.class),
        SETFUNCTIONBREAKPOINTS("setFunctionBreakpoints", SetFunctionBreakpointsArguments.class),
        EVALUATE("evaluate", EvaluateArguments.class),
        COMPLETIONS("completions", CompletionsArguments.class),
        RUNINTERMINAL("runInTerminal", RunInTerminalRequestArguments.class),
        REDEFINECLASSES("redefineClasses", RedefineClassesArguments.class),
        EXCEPTIONINFO("exceptionInfo", ExceptionInfoArguments.class),
        DATABREAKPOINTINFO("dataBreakpointInfo", DataBreakpointInfoArguments.class),
        SETDATABREAKPOINTS("setDataBreakpoints", SetDataBreakpointsArguments.class),
        CONTINUEALL("continueAll", ThreadOperationArguments.class),
        CONTINUEOTHERS("continueOthers", ThreadOperationArguments.class),
        PAUSEALL("pauseAll", ThreadOperationArguments.class),
        PAUSEOTHERS("pauseOthers", ThreadOperationArguments.class),
        INLINEVALUES("inlineValues", InlineValuesArguments.class),
        REFRESHVARIABLES("refreshVariables", RefreshVariablesArguments.class),
        PROCESSID("processId", Arguments.class),
        BREAKPOINTLOCATIONS("breakpointLocations", BreakpointLocationsArguments.class),
        REFRESHFRAMES("refreshFrames", RefreshFramesArguments.class),
        UNSUPPORTED("", Arguments.class);

        private String command;
        private Class<? extends Arguments> argumentType;

        Command(String command, Class<? extends Arguments> argumentType) {
            this.command = command;
            this.argumentType = argumentType;
        }

        public String getName() {
            return this.command;
        }

        @Override
        public String toString() {
            return this.command;
        }

        public Class<? extends Arguments> getArgumentType() {
            return this.argumentType;
        }

        /**
         * Get the corresponding Command type by the command name.
         * If the command is not defined in the enum type, return UNSUPPORTED.
         * @param command
         *             the command name
         * @return the Command type
         */
        public static Command parse(String command) {
            Command[] found = Arrays.stream(Command.values()).filter(cmd -> {
                return cmd.toString().equals(command);
            }).toArray(Command[]::new);

            if (found.length > 0) {
                return found[0];
            }
            return UNSUPPORTED;
        }
    }
}
